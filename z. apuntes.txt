Para comenzar a trabajar: npm start en api

Inicio: 13 de abril. 
PI descargado. Dejo una copia del BLANK en z. PI-Food-BLANK.
Repositorio git inicializado y sincronizado con gitHub. 
Archivo .env creado (falta el puerto).
DB food creada. 

Dudas:
- Por ahora los endpoints me muestran un 401, es porque para hacer requests tengo que hacerlo con la apikey creada? 
- Cuántas requests diarias puedo hacer? Me conviene guardar todo en mi DB hasta que termine el desarrollo? 
- index de routes. // Configurar los routers // Ejemplo: router.use('/auth', authRouter); // ??
- Cómo hago para ver TODOS los resultados al hacer el llamado a la API? No sé ni siquiera cuántos recipes hay. 
- Cómo manejo las diets que están en propiedades vs las que están en la propiedad Diets? Se duplican, es necesario usar las propiedades sueltas además de las de la propiedaD Diets? Por qué no incluir diaryFree dentro de las propiedades que van por separado igual que vegetarian, vegan y flutenFree? 
- Cómo se están relacionando los modelos?

- React. npm start: creo que servía para crear y actualizar el bundle. Confirmar. 
- React-router-dom está en versión 5, en vez de 6.3.0. Debería actualizarla? 
- El archivo App.jsx tendría que tener extensión .jsx? Es necesario importar React en ese archivo? 
- De la API externa me traigo todo el objeto Instructions o sólo los steps en un array? 


DB: relación many-to-many entre modelos Recipe y Diets. Comentados porque todavía no creé los modelos. 
DB: crear dos modelos -> recetas y dietas. 
npm i dentro de api
npm start. Levanta bien el server (dice Listening on port 3001 y Connected to DB). 
model Recipe: bien conectado con DB. Si le agrego atributos, se actualiza correctamente. 

Consignas: 
API: https://spoonacular.com/food-api
enpoints permitidos: 
https://api.spoonacular.com/recipes/complexSearch
https://api.spoonacular.com/recipes/complexSearch&addRecipeInformation=true
tipos de dieta: propiedades vegetarian, vegan, glutenFree, las incluidas en propiedad diets. 
https://api.spoonacular.com/recipes/{id}/information

Buscar recetas.
Visualizar la información de las recetas.
Filtrarlas.
Ordenarlas.
Crear nuevas recetas.
Filtrado y ordenamiento: no se pueden usar endpoints de api externa. 

commit added model Recipe
cambié Diets por Diet en archivo db.js

Creé la primera ruta. GET | /recipes/:idRecipe todavía sin implementar.
Probé la ruta en Postman y funciona. 
Por ahora, no modularizar. 
Siguiente paso: implementar esta ruta para ver si funcionan las requests a la api externa y si puedo combinarlo con la db. 
Instalé axios dentro de api. 
Cambié api_key como estaba en la consinga por apiKey, que es lo que indica la documentación de la API externa. 
La request a la API externa funciona correctamente. Guardé la response en archivo resExamp.json por si me quedo sin requests por día. 
En modelo Recipe, cambié el atributo healthScore por healthscore (minúscula).
Creé un primer registro en la tabla Recipes mediante sql shell. El código para hacerlo está en el archivo index de routes. Seteé force en true en archivo index general. 
Terminé la implementación de la primera ruta. Para no hacer requests por error a la API externa, dejé comentado el else de la primera ruta. 
Siguiente paso: seguir trabajando en archivo index de routes. Pasar a la segunda ruta. A futuro, modularizar. 

Creé la segunda ruta. '/recipes' con query name . Interpreté que es de esta manera aunque la consigna ubica el ? después del name en vez de ubicarlo antes. 
Implementé guardar las recetas que coinciden con el name del query provenientes de la DB. 
Siguiente paso: guardar las provenientes de la API externa. 
Guardé la response de la API externa al request general de recipes en mi archivo resExample.json. 
Implementé el llamado a la API externa. 
Agregué esta request a Postman. 
Implementé la segunda ruta '/recipes' con query name . No sé si busca otros nombres de la API externa porque todavía no sé cómo ver todos los recipes (tal vez debería buscar alguno por id para luego chequear si viene también buscando por su name). 
A futuro implementar que busque con mayúsculas o minúsculas y que la búsqueda no requiera ser exacta. 

Siguiente paso: tercera ruta. 
Armé la request en Postman. 
Desestructuré los datos que llegan por body en la ruta. 
Con el método create del modelo, creé una recipe en la ruta. Para verla en la DB, recordar apretar enter hasta que aparezca el registro. 
Para ver DB en psql, al ser varios registros, recordar \x para ver con claridad. 
En la función que crea el modelo (archivo Recipe.js), agregué el atributo diets. 
A futuro rever diets en Recipe.js, en ruta GET /recipes , en ruta POST /recipes y en Postman. 

Creé la ruta 4. GET /diets . Tomé la petición de la ruta 2, a futuro modularizar esta función. 
Inicialicé allDiets con tres propiedades (está hardcodeado o está ok). Las demás propiedades las tomé haciendo dos bucles: el primer recorre todas las apiRecipes, el segundo recorre dentro de cada apiRecipe su propiedad diets. Cada diet que no esté incluida en el arreglo allDiets se pushea a este arreglo. 
Siguiente paso: agregar los elementos del arreglo allDiets a la DB para que ya queden guardados ahí. 
Agregué el modelo Diet al archivo index.js de rutas. A futuro, modularizar. 
Quité el atributo created de la función que crea el modelo Diet (archivo Diet.js). 
Con un bucle forEach, agregué cada elemento del arreglo allDiets a la DB. 
El arreglo allDiets tiene un elemento glutenFree y un elemento gluten Free. Rever a futuro si está ok. 
A futuro, hacer que la petición a la API externa traiga todos los recipes, no solamente 10 (es la misma función que voy a necesitar para la ruta 2). 
Siguiente paso back-end: relacionar modelos (hasta ahora tengo la relación many-to-many, pero estoy tratando a las tablas como entidades totalmente separadas).
Paso futuro para el back-end: modularizar. 
git commit -m "added route get /diets"



FRONT-end
npm start: para compilar. 
Siguiente paso: comenzar front-end. 
Para el front-end, no enfocarme en los estilos. Ir a lo funcional. 
npm i en client.
Instalé la extensión Live Server en VSC. Abrí el HTML con Live Server. 
Dejé como estaban web vitals del package json y el archivo reportWebVitals.js contenido en src. Por las dudas de que los necesito a futuro.  
Probé agregar un div al html y se actualiza correctamente con el Live Server. 
npm run build lo voy a usar recién para el deployment. 
Cambié el title del html a PI-Food. 
Probé agregar un div desde el componente App y funciona correctamente. 
Cambié el background-color del body (archivo index.css) a black y el color a white.
                        

Actualicé las versiones en package.json de: React, React-dom, React-router-dom, React-redux, React-scripts. Volví a hacer npm i. 
Siguiente paso: hacer el ruteo desde el archivo index.js 
Archivo index.js . Reemplacé el código de ReactDom.render(...) por otro, dejando el que estaba como comentado. 
archivo index.js. Envolví al componente App en el BrowserRouter (y lo importé). A futuro, envolver con Provider store (para conectar con redux). 
Archivo App.js. Hice los imports de React, Routes y Route. Reescribí el componente App, cambiándolo a función flecha y agregándole rutas. 
Creé la carpeta components dentro de src. Dentro de components, creé la carpeta Landing, y dentro de ella Landing.jsx y Landing.module.css. Exporté el componente Landing, lo importé en App.js y creé la ruta correspondiente. 

Siguiente paso: implementar Landing.jsx 
Creé carpeta assets dentro de src. Ahí van las imágenes. 
Landing. Importé React. Agregué un breve texto. Importé styles y agregué una imagen al archivo landing.module.css. Cambié la imagen directamente al Landing.jsx para controlar su opacity desde el module.css. 
A futuro, acomodar los estilos. 
Agregué botón para ingresar a la Home desde la Landing. 
Agregué archivo Home, todavía sin implementar. 
Agregué ruta a Home desde App.js. 
Hasta ahora se puede hacer npm start, entrar a localgost:3000/landing, y desde allí apretar el botón que redirige a /home y carga correctamente. 
git commit -m "implemented Landing and added Home"

Siguiente paso: Crear componentes que se renderizan en Home.jsx. Basarme en Landing y en proyectos anteriores como Rick, reactdesdecero y CP. 
Creé los archivos de lso componentes que se renderizan en Home. Son los siguientes: SearchBar, Cards, Filters, Sorting, Pagination. 
Creé un componente estándar en cada componente que se renderiza en Home, lo exporté, lo importé y rendericé en Home.jsx. 

Siguiente paso: crear componente Detail y renderizarlo en Cards.jsx . A futuro, vista del  Form. 
git commit -m "added SearchBar, Cards, Filters, Sorting, Pagination".

Creé ruta detail/id en App.js. A futuro cambiarlo por ruta dinámica. 
Creé archivo Detail.jsx con un componente estándar, lo exporté, lo importé y rendericé en Home. En Cards importé Link y agregué el link a Detail, que a futuro tiene que ser dinámico según el id de la recipe. 

Creé archivo Form.jsx con un componente estándar, lo exporté, lo importé y rendericé en Home. 
Agregué componente Nav que se renderice en Home por fuera de las rutas. Este componente Nav debe tener un link al Form. 
A futuro, evitar que el Nav se renderice en la Landing (usar renderizado condicional). 
Siguiente paso: dentro del Nav los componentes SearchBar, Filters y Sorting. 
git commit -m "added Detail, Form, Nav"

Pasé los imports y renderizaciones de los componentes SearchBar, Filters y Sorting de Home.jsx a Nav.jsx. 
Siguiente paso: implementación visual mínima de los componentes contenidos en Nav para ir dándome una idea. Empezar por SearchBar. 

SearchBar.jsx. Agregué un input. A futuro, agregar funcionalidad. 
Filters.jsx. Agregué dos inputs. A futuro, agregar funcionalidad. 
Sorting.jsx. Agregué dos buttons. A futuro, agregar funcionalidad. 

Siguiente paso: implementar componente Cards. Basarme en proyecto Rick. 
git commit -m "SearchBar, Filters, Sorting rendered by Nav and added basic inputs and buttons"

Agregué archivo Card.jsx que contiene el componente Card que se exporta y se renderiza en Cards.jsx. 

Siguiente paso: implementar Card y Cards usando props. A futuro, chequear si es mejor así o usar Redux. 
Archivo.jsx. Importé los hooks useEffect y useState. importé axios. npm i axios dentro de client. Dentro del componente App, inicializo el state recipes como un arreglo vacío. Visualizo en consola web (en Components) que se carga correctamente el state. 
Hice una petición a mi back-end con get /recipes, harcodeando el query name. 
Siguiente paso: cargar la card con la petición harcodeada. Luego, corregir el back para poder hacer la request sin query y que traiga todas las recipes. Luego, crear esl reducer para guardar el estado general del cliente, mostrando las recipes adecuadas, según los filtros. 

hacer npm start en el cliente y npm start en el back. dejé comentada la request a la api externa para no exceder las consultas diarias. 
git commit -m "added Card and added basic request from client to api in App component"


// VOLVI AL BACK - END.  
// Apuntes para agregar a partir del Repaso de Selene. 
pgAdmin. Servers, PostgreSQL, Databases, click derecho, refresh. Food, Schemas, Tables, click derecho sobre una tabla, View, All rows. 
Modelo Diet: cambiar UUID por INTEGER. 
Creé un diagrama de los modelos en app.diagrams.net. 
Por lo que entendí, el atributo Diets en Recipe no va. 

Archivo index.js. Ruta 2: agregar la posibilidad de que no haya query, para traer todas las recipes de la API externa. 


Archivo index.js de routes. Ruta GET /recipes. Agregué un if(!query) dentro del try e implementé que la ruta traiga todas las recipes si no hay query. Cambié nombre de propiedad title por name, para unificar con mi DB. 
git commit -m "enable GET /recipes endpoint to fetch all recipes in addition to filtered queries". 
Vi hasta min 32 de Selene. 

Siguiente paso: modularizar ruta GET /recipes del archivo index.js.
Creé archivo recipesRouter.js y dietsRouter.js dentro de carpeta routes. 
Cambié el nombre de router por mainRouter. 
Creé archivo SQL con los ejemplos que usé para cargar la db.  
Archivo recipesRouter.js. Trasladé lo que tenía en index.js. 
Creé carpetas handlers y controllers. En cada una creé handlers y controllers para recipes y para diets. 
Creé una función estándar en recipesHandlers.js para exportar y luego importarla en recipesROuter.js. 
Están creados los archivos en los que voy a modularizar index.js pero todavía no les pasé el código de este archivo index a los handlers y controllers. 
git commit -m "added routers, handlers and controllers files for recipes and diets. NIY"

Siguiente paso: trasladar código de index.js a handlers y controllers. 
Cambié el nombre de index.js (en carpeta routes) por indexRouter.js porque me resulta más claro. Adapté el import en app.js. 
Pasé axios, doenv, api_key y modelos desde indexRouter.js a recipesController.js. 
Cambié el nombre de idRecipe por id (req.params.idRecipe, en vez de desestructurarlo). 
Corregí el controller searchRecipeById para que traiga de la API externa sólo las propiedades que necesito. 
Modifiqué analizedInstructions por instructions, que es más abreviada y creo que es la que necesito. 

Próximo paso: modularizar ruta 2 (GET /recipes).
git commit -m "modularized GET /recipes:idRecipe . improved searchRecipeById controller to show less properties from the external api"

Creé controllers searchAllRecipes y searchRecipesByName. Los exporté y los importé en recipesHandler.js. 
Modularicé la ruta GET /recipes. 
Implementé getRecipesHandler. Siguiente paso: implementar los dos controllers que usa este handler. 
Implementé controller SearchAllRecipes. Lo adapté para que instructions mapee y traiga sólos los steps. Copié en resExamp.json las respuestas de la API externa y la lógica para llegar al código del mapeo de instructions. 

Siguiente paso: implementar searchRecipesByName (el código está comentado en el archivo recipesHandler.js, en el else de getRecipesHandler)
git commit -m "modularized getRecipesHandler and implemented searchAllRecipes". 

Le pasé el argumento name a searchRecipesByName. 
Implementé el controller searchAllRecipes. Lo adapté para que haga las búsquedas que incluyan name y no sólo las que coinciden exactamente. Importé op en recipesCOntrollers.js. 
Borré el código comentado en recipesHandler que ya está modularizado.
git commit -m "implemented searchRecipesByName. added inexact queries"
Siguiente paso: modularizar la ruta 3. 

Borré la ruta 2 antigua de indexRouter.js que ya se modularizó completamente. 
Creé el controller createRecipe. Lo exporté y lo importé en recipesHandler.js. 
Quité el id de createRecipeHandler, porque no se recibe por body, sino que lo genera sequelize con el método .create() del modelo Recipe. 
Quité el id en Postman. 
En Postman agregué diets. A futuro, implementar que al crear receta se usen las diets.  
Borré la ruta 3 antigua de indexRouter.js porque ya se modularizó completamente. 
git commit -m "implemented createRecipe controller. deleted id from req.body"

Siguiente paso: modularizar la ruta 4. 
Modularicé la ruta 4. Implementé el controller getDiets y el handler getDietsHandler. 
Creé archivo back-flow que muestra el flujo del back-end. 
Creé archivo front-flow. Pasé el flujo que tenía en este archivo apuntes.txt al nuevo archivo. 
git commit -m "implemented getDiets controller"

Siguiente paso: seguir viendo video de Selene. Dudas principales: cómo traer más de 10 resultados de la api externa. recordar cómo se crea la aplicación de redux. 
minuto 24 de Selene. Muestra el include para traer la info de los dos modelos. 

Modifiqué controller searchAllRecipes para que dbAllRecipesRaw tenga el include del modelo Diet.
Importé el modelo Diet a recipesControllers.js. 
Agregué la carpeta helpers dentro de src para modularizar los controllers. 
Modularicé el controller searchAllRecipes.
git commit -m "Separated searchAllRecipes concerns into dedicated helper functions". 
Siguiente paso: modularizar searchRecioesByName usando helpers. 
Refactoricé searchRecipesByName reutilizando el controller searchAllRecipes y luego aplicándole un filter a todo el arreglo. 
git commit -m "refactored searchRecipesByName".

Siguiente paso: modularizar searchRecipeById. 
Corregí el controller searchRecipeById para que retorne recipeByIdClean.dataValues (le agregué el .dataValues). 

Refactorizar helpers para que haya funciones para una recipe, y luego esa función se reutilice en el mapeo con todas las recipes. 
Agregué helpers para procesar de a una recipe: getDbRecipeByIdRaw, cleanDbRecipe, getDbRecipeByIdClean. getDbRecipeByIdRaw fue corregido para que la respuesta incluya el resultado del modelo Diet (además del modelo Recipe). 
git commit -m "implemented helpers for searchRecipeById controller. Refactored the other helpers"

Modularicé helpers en: dbRecipesHelper.js y apiRecipesHelper.js. 
searchRecipesByName no está funcionando el includes ni el toLowerCase, no entiendo por qué. 
git commit -m "modularized helpers. searchRecipesByName is not working properly"
Otro problema; getRecipesHandler sin query name no trae todas las propiedades (rever helper cleanAllApiRecipes) y cleanApiRecipe. 
Los problemas se daban porque en la api las propiedades que yo desestructuré como name y healthscore figuran como title y healthScore respectivamente. 
Corregí el helper cleanApiRecipe. 
git commit -m "fixed cleanApiRecipe". 


Siguiente paso: retomar video de Selene. Sigo con las mismas dudas:
Dudas principales: cómo traer más de 10 resultados de la api externa. recordar cómo se crea la aplicación de redux. 
minuto 24 de Selene. Muestra el include para traer la info de los dos modelos. 

Modifiqué el helper getAllApiRecipesRaw para que traiga más de 10 resultados, usando offset. Ya trae los resultados que indique en la variable numberOfResults. 
No está funcionando correctamente cleanApiRecipe, ya que trae algunas recipes bien, pero con otras retorna "error": "Cannot read properties of undefined (reading 'steps')". Comenté la línea de steps para corregirlo a futuro. 
En helpers.js agregué la variable baseURL y reemplacé el principio del endpoint tanto para todas las recipes como para la búsqueda por id. 
Para ver qué trae la API usar los endpoints directamente en la web. 
La propiedad analizedInstructions en algunas recipes viene vacía. Por lo tanto, hay que validar esto. 
Corregí steps agregándole previamente la validación if (analyzedInstructions.length). Si no hay analyzedInstructions en la api externa, steps retornará []; Funciona correctamente. 
Actualicé en resExample.json lo que trae la API externa (primeros 100 resultados). 
git commit -m "Enhanced cleanApiRecipe helper with property step validation and increased getAllApiRecipesRaw results to 100"