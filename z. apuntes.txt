////////////////////    !!!!!!!!!!!!!!!!!!!! ///////////////////////
Regular requests: 

recipesControllers.js ---> searchAllRecipes
apiRecipesHelpers.js  ---> getAllApiRecipesRaw (number of results)    
actionsIndex.js ---> getDiets

////////////////////    !!!!!!!!!!!!!!!!!!!! ///////////////////////



Para comenzar a trabajar: npm start en api

Inicio: 13 de abril. 
PI descargado. Dejo una copia del BLANK en z. PI-Food-BLANK.
Repositorio git inicializado y sincronizado con gitHub. 
Archivo .env creado (falta el puerto).
DB food creada. 

Dudas:
- Por ahora los endpoints me muestran un 401, es porque para hacer requests tengo que hacerlo con la apikey creada? 
- Cuántas requests diarias puedo hacer? Me conviene guardar todo en mi DB hasta que termine el desarrollo? 
- index de routes. // Configurar los routers // Ejemplo: router.use('/auth', authRouter); // ??
- Cómo hago para ver TODOS los resultados al hacer el llamado a la API? No sé ni siquiera cuántos recipes hay. 
- Cómo manejo las diets que están en propiedades vs las que están en la propiedad Diets? Se duplican, es necesario usar las propiedades sueltas además de las de la propiedaD Diets? Por qué no incluir diaryFree dentro de las propiedades que van por separado igual que vegetarian, vegan y flutenFree? 
- Cómo se están relacionando los modelos?

- React. npm start: creo que servía para crear y actualizar el bundle. Confirmar. 
- React-router-dom está en versión 5, en vez de 6.3.0. Debería actualizarla? 
- El archivo App.jsx tendría que tener extensión .jsx? Es necesario importar React en ese archivo? 
- De la API externa me traigo todo el objeto Instructions o sólo los steps en un array? 


DB: relación many-to-many entre modelos Recipe y Diets. Comentados porque todavía no creé los modelos. 
DB: crear dos modelos -> recetas y dietas. 
npm i dentro de api
npm start. Levanta bien el server (dice Listening on port 3001 y Connected to DB). 
model Recipe: bien conectado con DB. Si le agrego atributos, se actualiza correctamente. 

Consignas: 
API: https://spoonacular.com/food-api
enpoints permitidos: 
https://api.spoonacular.com/recipes/complexSearch
https://api.spoonacular.com/recipes/complexSearch&addRecipeInformation=true
tipos de dieta: propiedades vegetarian, vegan, glutenFree, las incluidas en propiedad diets. 
https://api.spoonacular.com/recipes/{id}/information

Buscar recetas.
Visualizar la información de las recetas.
Filtrarlas.
Ordenarlas.
Crear nuevas recetas.
Filtrado y ordenamiento: no se pueden usar endpoints de api externa. 

commit added model Recipe
cambié Diets por Diet en archivo db.js

Creé la primera ruta. GET | /recipes/:idRecipe todavía sin implementar.
Probé la ruta en Postman y funciona. 
Por ahora, no modularizar. 
Siguiente paso: implementar esta ruta para ver si funcionan las requests a la api externa y si puedo combinarlo con la db. 
Instalé axios dentro de api. 
Cambié api_key como estaba en la consinga por apiKey, que es lo que indica la documentación de la API externa. 
La request a la API externa funciona correctamente. Guardé la response en archivo resExamp.json por si me quedo sin requests por día. 
En modelo Recipe, cambié el atributo healthScore por healthscore (minúscula).
Creé un primer registro en la tabla Recipes mediante sql shell. El código para hacerlo está en el archivo index de routes. Seteé force en true en archivo index general. 
Terminé la implementación de la primera ruta. Para no hacer requests por error a la API externa, dejé comentado el else de la primera ruta. 
Siguiente paso: seguir trabajando en archivo index de routes. Pasar a la segunda ruta. A futuro, modularizar. 

Creé la segunda ruta. '/recipes' con query name . Interpreté que es de esta manera aunque la consigna ubica el ? después del name en vez de ubicarlo antes. 
Implementé guardar las recetas que coinciden con el name del query provenientes de la DB. 
Siguiente paso: guardar las provenientes de la API externa. 
Guardé la response de la API externa al request general de recipes en mi archivo resExample.json. 
Implementé el llamado a la API externa. 
Agregué esta request a Postman. 
Implementé la segunda ruta '/recipes' con query name . No sé si busca otros nombres de la API externa porque todavía no sé cómo ver todos los recipes (tal vez debería buscar alguno por id para luego chequear si viene también buscando por su name). 
A futuro implementar que busque con mayúsculas o minúsculas y que la búsqueda no requiera ser exacta. 

Siguiente paso: tercera ruta. 
Armé la request en Postman. 
Desestructuré los datos que llegan por body en la ruta. 
Con el método create del modelo, creé una recipe en la ruta. Para verla en la DB, recordar apretar enter hasta que aparezca el registro. 
Para ver DB en psql, al ser varios registros, recordar \x para ver con claridad. 
En la función que crea el modelo (archivo Recipe.js), agregué el atributo diets. 
A futuro rever diets en Recipe.js, en ruta GET /recipes , en ruta POST /recipes y en Postman. 

Creé la ruta 4. GET /diets . Tomé la petición de la ruta 2, a futuro modularizar esta función. 
Inicialicé allDiets con tres propiedades (está hardcodeado o está ok). Las demás propiedades las tomé haciendo dos bucles: el primer recorre todas las apiRecipes, el segundo recorre dentro de cada apiRecipe su propiedad diets. Cada diet que no esté incluida en el arreglo allDiets se pushea a este arreglo. 
Siguiente paso: agregar los elementos del arreglo allDiets a la DB para que ya queden guardados ahí. 
Agregué el modelo Diet al archivo index.js de rutas. A futuro, modularizar. 
Quité el atributo created de la función que crea el modelo Diet (archivo Diet.js). 
Con un bucle forEach, agregué cada elemento del arreglo allDiets a la DB. 
El arreglo allDiets tiene un elemento glutenFree y un elemento gluten Free. Rever a futuro si está ok. 
A futuro, hacer que la petición a la API externa traiga todos los recipes, no solamente 10 (es la misma función que voy a necesitar para la ruta 2). 
Siguiente paso back-end: relacionar modelos (hasta ahora tengo la relación many-to-many, pero estoy tratando a las tablas como entidades totalmente separadas).
Paso futuro para el back-end: modularizar. 
git commit -m "added route get /diets"



FRONT-end
npm start: para compilar. 
Siguiente paso: comenzar front-end. 
Para el front-end, no enfocarme en los estilos. Ir a lo funcional. 
npm i en client.
Instalé la extensión Live Server en VSC. Abrí el HTML con Live Server. 
Dejé como estaban web vitals del package json y el archivo reportWebVitals.js contenido en src. Por las dudas de que los necesito a futuro.  
Probé agregar un div al html y se actualiza correctamente con el Live Server. 
npm run build lo voy a usar recién para el deployment. 
Cambié el title del html a PI-Food. 
Probé agregar un div desde el componente App y funciona correctamente. 
Cambié el background-color del body (archivo index.css) a black y el color a white.
                        

Actualicé las versiones en package.json de: React, React-dom, React-router-dom, React-redux, React-scripts. Volví a hacer npm i. 
Siguiente paso: hacer el ruteo desde el archivo index.js 
Archivo index.js . Reemplacé el código de ReactDom.render(...) por otro, dejando el que estaba como comentado. 
archivo index.js. Envolví al componente App en el BrowserRouter (y lo importé). A futuro, envolver con Provider store (para conectar con redux). 
Archivo App.js. Hice los imports de React, Routes y Route. Reescribí el componente App, cambiándolo a función flecha y agregándole rutas. 
Creé la carpeta components dentro de src. Dentro de components, creé la carpeta Landing, y dentro de ella Landing.jsx y Landing.module.css. Exporté el componente Landing, lo importé en App.js y creé la ruta correspondiente. 

Siguiente paso: implementar Landing.jsx 
Creé carpeta assets dentro de src. Ahí van las imágenes. 
Landing. Importé React. Agregué un breve texto. Importé styles y agregué una imagen al archivo landing.module.css. Cambié la imagen directamente al Landing.jsx para controlar su opacity desde el module.css. 
A futuro, acomodar los estilos. 
Agregué botón para ingresar a la Home desde la Landing. 
Agregué archivo Home, todavía sin implementar. 
Agregué ruta a Home desde App.js. 
Hasta ahora se puede hacer npm start, entrar a localgost:3000/landing, y desde allí apretar el botón que redirige a /home y carga correctamente. 
git commit -m "implemented Landing and added Home"

Siguiente paso: Crear componentes que se renderizan en Home.jsx. Basarme en Landing y en proyectos anteriores como Rick, reactdesdecero y CP. 
Creé los archivos de lso componentes que se renderizan en Home. Son los siguientes: SearchBar, Cards, Filters, Sorting, Pagination. 
Creé un componente estándar en cada componente que se renderiza en Home, lo exporté, lo importé y rendericé en Home.jsx. 

Siguiente paso: crear componente Detail y renderizarlo en Cards.jsx . A futuro, vista del  Form. 
git commit -m "added SearchBar, Cards, Filters, Sorting, Pagination".

Creé ruta detail/id en App.js. A futuro cambiarlo por ruta dinámica. 
Creé archivo Detail.jsx con un componente estándar, lo exporté, lo importé y rendericé en Home. En Cards importé Link y agregué el link a Detail, que a futuro tiene que ser dinámico según el id de la recipe. 

Creé archivo Form.jsx con un componente estándar, lo exporté, lo importé y rendericé en Home. 
Agregué componente Nav que se renderice en Home por fuera de las rutas. Este componente Nav debe tener un link al Form. 
A futuro, evitar que el Nav se renderice en la Landing (usar renderizado condicional). 
Siguiente paso: dentro del Nav los componentes SearchBar, Filters y Sorting. 
git commit -m "added Detail, Form, Nav"

Pasé los imports y renderizaciones de los componentes SearchBar, Filters y Sorting de Home.jsx a Nav.jsx. 
Siguiente paso: implementación visual mínima de los componentes contenidos en Nav para ir dándome una idea. Empezar por SearchBar. 

SearchBar.jsx. Agregué un input. A futuro, agregar funcionalidad. 
Filters.jsx. Agregué dos inputs. A futuro, agregar funcionalidad. 
Sorting.jsx. Agregué dos buttons. A futuro, agregar funcionalidad. 

Siguiente paso: implementar componente Cards. Basarme en proyecto Rick. 
git commit -m "SearchBar, Filters, Sorting rendered by Nav and added basic inputs and buttons"

Agregué archivo Card.jsx que contiene el componente Card que se exporta y se renderiza en Cards.jsx. 

Siguiente paso: implementar Card y Cards usando props. A futuro, chequear si es mejor así o usar Redux. 
Archivo.jsx. Importé los hooks useEffect y useState. importé axios. npm i axios dentro de client. Dentro del componente App, inicializo el state recipes como un arreglo vacío. Visualizo en consola web (en Components) que se carga correctamente el state. 
Hice una petición a mi back-end con get /recipes, harcodeando el query name. 
Siguiente paso: cargar la card con la petición harcodeada. Luego, corregir el back para poder hacer la request sin query y que traiga todas las recipes. Luego, crear esl reducer para guardar el estado general del cliente, mostrando las recipes adecuadas, según los filtros. 

hacer npm start en el cliente y npm start en el back. dejé comentada la request a la api externa para no exceder las consultas diarias. 
git commit -m "added Card and added basic request from client to api in App component"


// VOLVI AL BACK - END.  
// Apuntes para agregar a partir del Repaso de Selene. 
pgAdmin. Servers, PostgreSQL, Databases, click derecho, refresh. Food, Schemas, Tables, click derecho sobre una tabla, View, All rows. 
Modelo Diet: cambiar UUID por INTEGER. 
Creé un diagrama de los modelos en app.diagrams.net. 
Por lo que entendí, el atributo Diets en Recipe no va. 

Archivo index.js. Ruta 2: agregar la posibilidad de que no haya query, para traer todas las recipes de la API externa. 


Archivo index.js de routes. Ruta GET /recipes. Agregué un if(!query) dentro del try e implementé que la ruta traiga todas las recipes si no hay query. Cambié nombre de propiedad title por name, para unificar con mi DB. 
git commit -m "enable GET /recipes endpoint to fetch all recipes in addition to filtered queries". 
Vi hasta min 32 de Selene. 

Siguiente paso: modularizar ruta GET /recipes del archivo index.js.
Creé archivo recipesRouter.js y dietsRouter.js dentro de carpeta routes. 
Cambié el nombre de router por mainRouter. 
Creé archivo SQL con los ejemplos que usé para cargar la db.  
Archivo recipesRouter.js. Trasladé lo que tenía en index.js. 
Creé carpetas handlers y controllers. En cada una creé handlers y controllers para recipes y para diets. 
Creé una función estándar en recipesHandlers.js para exportar y luego importarla en recipesROuter.js. 
Están creados los archivos en los que voy a modularizar index.js pero todavía no les pasé el código de este archivo index a los handlers y controllers. 
git commit -m "added routers, handlers and controllers files for recipes and diets. NIY"

Siguiente paso: trasladar código de index.js a handlers y controllers. 
Cambié el nombre de index.js (en carpeta routes) por indexRouter.js porque me resulta más claro. Adapté el import en app.js. 
Pasé axios, doenv, api_key y modelos desde indexRouter.js a recipesController.js. 
Cambié el nombre de idRecipe por id (req.params.idRecipe, en vez de desestructurarlo). 
Corregí el controller searchRecipeById para que traiga de la API externa sólo las propiedades que necesito. 
Modifiqué analizedInstructions por instructions, que es más abreviada y creo que es la que necesito. 

Próximo paso: modularizar ruta 2 (GET /recipes).
git commit -m "modularized GET /recipes:idRecipe . improved searchRecipeById controller to show less properties from the external api"

Creé controllers searchAllRecipes y searchRecipesByName. Los exporté y los importé en recipesHandler.js. 
Modularicé la ruta GET /recipes. 
Implementé getRecipesHandler. Siguiente paso: implementar los dos controllers que usa este handler. 
Implementé controller SearchAllRecipes. Lo adapté para que instructions mapee y traiga sólos los steps. Copié en resExamp.json las respuestas de la API externa y la lógica para llegar al código del mapeo de instructions. 

Siguiente paso: implementar searchRecipesByName (el código está comentado en el archivo recipesHandler.js, en el else de getRecipesHandler)
git commit -m "modularized getRecipesHandler and implemented searchAllRecipes". 

Le pasé el argumento name a searchRecipesByName. 
Implementé el controller searchAllRecipes. Lo adapté para que haga las búsquedas que incluyan name y no sólo las que coinciden exactamente. Importé op en recipesCOntrollers.js. 
Borré el código comentado en recipesHandler que ya está modularizado.
git commit -m "implemented searchRecipesByName. added inexact queries"
Siguiente paso: modularizar la ruta 3. 

Borré la ruta 2 antigua de indexRouter.js que ya se modularizó completamente. 
Creé el controller createRecipe. Lo exporté y lo importé en recipesHandler.js. 
Quité el id de createRecipeHandler, porque no se recibe por body, sino que lo genera sequelize con el método .create() del modelo Recipe. 
Quité el id en Postman. 
En Postman agregué diets. A futuro, implementar que al crear receta se usen las diets.  
Borré la ruta 3 antigua de indexRouter.js porque ya se modularizó completamente. 
git commit -m "implemented createRecipe controller. deleted id from req.body"

Siguiente paso: modularizar la ruta 4. 
Modularicé la ruta 4. Implementé el controller getDiets y el handler getDietsHandler. 
Creé archivo back-flow que muestra el flujo del back-end. 
Creé archivo front-flow. Pasé el flujo que tenía en este archivo apuntes.txt al nuevo archivo. 
git commit -m "implemented getDiets controller"

Siguiente paso: seguir viendo video de Selene. Dudas principales: cómo traer más de 10 resultados de la api externa. recordar cómo se crea la aplicación de redux. 
minuto 24 de Selene. Muestra el include para traer la info de los dos modelos. 

Modifiqué controller searchAllRecipes para que dbAllRecipesRaw tenga el include del modelo Diet.
Importé el modelo Diet a recipesControllers.js. 
Agregué la carpeta helpers dentro de src para modularizar los controllers. 
Modularicé el controller searchAllRecipes.
git commit -m "Separated searchAllRecipes concerns into dedicated helper functions". 
Siguiente paso: modularizar searchRecioesByName usando helpers. 
Refactoricé searchRecipesByName reutilizando el controller searchAllRecipes y luego aplicándole un filter a todo el arreglo. 
git commit -m "refactored searchRecipesByName".

Siguiente paso: modularizar searchRecipeById. 
Corregí el controller searchRecipeById para que retorne recipeByIdClean.dataValues (le agregué el .dataValues). 

Refactorizar helpers para que haya funciones para una recipe, y luego esa función se reutilice en el mapeo con todas las recipes. 
Agregué helpers para procesar de a una recipe: getDbRecipeByIdRaw, cleanDbRecipe, getDbRecipeByIdClean. getDbRecipeByIdRaw fue corregido para que la respuesta incluya el resultado del modelo Diet (además del modelo Recipe). 
git commit -m "implemented helpers for searchRecipeById controller. Refactored the other helpers"

Modularicé helpers en: dbRecipesHelper.js y apiRecipesHelper.js. 
searchRecipesByName no está funcionando el includes ni el toLowerCase, no entiendo por qué. 
git commit -m "modularized helpers. searchRecipesByName is not working properly"
Otro problema; getRecipesHandler sin query name no trae todas las propiedades (rever helper cleanAllApiRecipes) y cleanApiRecipe. 
Los problemas se daban porque en la api las propiedades que yo desestructuré como name y healthscore figuran como title y healthScore respectivamente. 
Corregí el helper cleanApiRecipe. 
git commit -m "fixed cleanApiRecipe". 



Modifiqué el helper getAllApiRecipesRaw para que traiga más de 10 resultados, usando offset. Ya trae los resultados que indique en la variable numberOfResults. 
No está funcionando correctamente cleanApiRecipe, ya que trae algunas recipes bien, pero con otras retorna "error": "Cannot read properties of undefined (reading 'steps')". Comenté la línea de steps para corregirlo a futuro. 
En helpers.js agregué la variable baseURL y reemplacé el principio del endpoint tanto para todas las recipes como para la búsqueda por id. 
Para ver qué trae la API usar los endpoints directamente en la web. 
La propiedad analizedInstructions en algunas recipes viene vacía. Por lo tanto, hay que validar esto. 
Corregí steps agregándole previamente la validación if (analyzedInstructions.length). Si no hay analyzedInstructions en la api externa, steps retornará []; Funciona correctamente. 
Actualicé en resExample.json lo que trae la API externa (primeros 100 resultados). 
git commit -m "Enhanced cleanApiRecipe helper with property step validation and increased getAllApiRecipesRaw results to 100". 


Corregí funcionalidad de dietsControllers para que busque en 100 recetas, no sólo en las primeras 10. 
Corregí dietsController para uqe ejecute findOrCreate en vez de create, y lo corregí para que maneje adecuadamente las promesas con Promise.all. A futuro, chequear que esté bien aplicado el Promise.all y si debería aplicarlo también en getAllApiRecipesRaw. 

git commit -m "enhanced getDiets controller to query more results and to handle the findOrCreate promises"

Modifiqué el controller getDiets para usar un for of con await en vez del Promise.all porque lo entiendo más (a pesar de que sea menos óptimo). 
Agregué el controller getDietsFromDb. Ahora getDietsHandler hace la búsqueda inicialmente en la api, carga los datos en la db, y a partir de la segunda búsqueda, va directamente a la db. 
git commit -m "added getDietsFromDb controller. Now getDietsHandler queries the db after the first query"


Agregué diets al helper cleanApiRecipe. 
A futuro, agregar algunos manejos de errores, por ejemplo si no existe un determinado id, o si no se encuentran coincidencias con un name. 
git commit -m "added property diets to cleanApiRecipe helper"

Siguiente paso: Corregir la ruta del POST para asociar con diets.


//////////////////////////////////////////
Cambié instructions por steps en createRecipeHandler, en controller createRecipe y en el model Recipe.js. 
En attribute steps de Recipe.js cambié DataTypes.TEXT por type: DataTypes.ARRAY(DataTypes.STRING). 
// archivo index.js. Cambié sync de force: false a force: true, para poder crear recetas nuevas ahora que cambié la columna instructions por steps. Se borran todos los registros. 
Modelo Diet.js quité el atributo id porque lo genera sequelize automáticamente. 
Dejé Diet.js con el UUID para ver si funciona, pero me quedé sin requests por el día. Chequear al día siguiente. 

Ver requests diarias: https://spoonacular.com/food-api/console#Dashboard
getDietsFromApi controller. No está funcionando correctamente el for of. 
En 1h12' Selene explica cómo hacer createRecipe controller. 

Endpoints chequeados: 
GET /recipes/1
GET /recipes
GER /recipes?name=ana
GET /diets

Cambié sync a force: false. 
Agregué que el controller createRecipe usa el método addDiets sobre el objeto creado newRecipe para asociar dietas. 

Pasos para chequear requests: 
1. GET /diets para que se carguen diets en DB (antes de esto no puedo crear una recipe, ya que cada registro nuevo de una recipe tiene que asociarse a las diets que se extraen de la tabla Diet). Esto lo hago una sola vez si sync está en force: false. Si no, lo tengo que hacer cada vez que levanto el servidor. 
2. POST /recipes . 

// Ahora parece estar funcionando todo (creo que porque devolví el attribute id de diets al type UUID). Chequear si se traen correctamente las diets en GET /recipes.
git commit -m "changed instructions recipe attribute for steps. Associated recipe with diets in createRecipe controller". 

En createRecipe controller, Selene agregó un código que no entiendo del todo. Leer documentación de sequelize: Associations, special methods/mixins added to instances, Foo.nelongsToMany(Bar, [throughL Baz])
El método addDiets es creado por Sequelize. La instancia de un modelo relacionado con otro adquiere métodos con, por ejemplo, add, concatenado al nombre del modelo relacionado. newRecipe (instancia de Recipe) .addDiets espera como argumento un arreglo de instancias de Diet. 
Agregué el await a newRecipe.addDiets (en createRecipe controller). Supongo que Selene se lo había olvidado. 
Chequeé hacer un request GET /recipes/{UUID de ejemplo de la db}, y la propiedad Diets trae un array de objetos:
    [
        {
            "name": "vegetarian"
        },
        {
            "name": "vegan"
        }
    ]
Agregué la variable includeObject, y reemplacé en los helpers getDbRecipeByIdRaw y getAllDbRecipesRaw. 
Refactoricé cleanDbRecipe helper para que en vez de traer Diets con un array de objetos con la propiedad name, directamente traiga un array de strings con los valores de name. 
Refactoricé cleanAllDbRecipes con el mismo criterio. 
Refactoricé cleanAllApiRecipe para que tuviera un código análogo a cleanAllDbRecipe. 
Refactoricé cleanApiRecipe para mejor legibilidad. 

git commit -m "improved cleanDbRecipe and cleanAllDbRecipes helpers to bring diets instead of Diets. Improved readability of createRecipe controller, cleanApiRecipe".

Agregué mensaje de error en controller searchRecipesByName y en helper getDbRecipeByIdRaw. 
Intenté agregar mensaje de error en getApiRecipeByIdRaw helpers, pero no funciona porque da 404. 
Actualicé archivo resExamp.json con respuestas actuales a las requests de: recipes, recipes por id db y api, diets. 
El back-end está funcionando completamente. A futuro, chequear que para GET /recipes asocie también las propiedas vegetarian, etc además de las de diets. 
git commit -m "added error messages in searchRecipesByName controller and in  getDbRecipeByIdRaw helper. Updated resExamp.json file. Whole back-end working properly"

Siguiente paso back-end: incluir propiedades vegetarian, vegan y gluten Free en la ruta GET /recipes. 
// por qué incluiría vegan y gluten free si ya están incluidas en la propiedad diets?

//////////////////////////
Siguiente paso: retomar FRONT-END. Redux. Videos Selene. 
Creé carpeta redux dentro de src. Dentro de reducer creé las carpetas store, reducer y actions con sus respectivos archivos index. 
storeIndex.js hice la configuración del store. Importé el reducer de reducerIndex.js. Dejé el compose, también podría instalar composeWithDevTools para simplificar código. 
reducerIndex.js. Hice un reducer básico. 
actionsIndex.js. Hice una action-creator que por ahora retorna sólo undefined. 
index.js. El método .render de ReactDom fue reemplazado createRoot, pero lo dejé así para no cambiar la configuración inicial del proyecto. Envolví al BrowserRouter (que envuelve a App) con Provider store={store} para conectar redux con mi App. 
git commit -m "front-end. Initialized Redux store, reducer and actions". 
Siguiente paso: a partir del proyecto de Rick, ver en qué se usó props y en qué se usó Redux. Apoyarme en documentación de React para recordar props. Y videos de Selene para pensar el flujo general de toda la app. 
Primer paso principal: mostrar cards de recipes en Home.

video Selene: minuto 19. 
Componente Landing. Cambié NavLink por Link. 
actionsIndex.js. Creé la action creator getRecipes. 
Componente Home.jsx. Importé useState y useEffect. Importé useDispatch y useSelector. Importé getRecipes. 
Borré el useEffect y el fetchRecipes de App, porque el global state se tiene que cargar una vez que hago click en Home, y no antes de renderizar la Landing. 
Implementé: Home hace un useDispatch dentro del useEffect para actualizar las recipes del globalState. Home renderiza Cards. Cards hace un useSelect para obtener las recipes del globalState. Cards hace un map de las recipes y por cada una renderiza un componente Card. Card renderiza las props recibidas (ya desestructuradas) incluyendo un Link con una ruta dinámica según el id de cada recipe recibido por props. En App.js la ruta detail/:id es dinámica, por lo que cualquier Card tendrá un link que redirigirá a una ruta que hace que App renderice el componente Detail.jsx
git commit -m "Recipes rendered using the global state"

Agregué el paginado. 
Home hace la lógica. Renderiza Cards y Pagination. Le pasa por props lo que necesita cada uno. Ahora Cards no renderiza allRecipes.map sino currentRecipes.map. 
En apiRecipesHelpers.js (de mi api) tengo la const numberOfResults para ir regulando cuánto traer de Spoonacular. 
Próximo paso: filtros. 
git commit -m "implemented Pagination.jsx and its logic in Home.jsx". 
Minuto 16 del video de Selene (lecture 3). 

Home.jsx. recipesPerPage lo saqué del state y lo pasé a una const normal. 
Video de Selene lecture 3: 28'30'' empieza con filtros. 

A futuro, componente Detail. Tomar el id de params (creo que hay un hook). Guardar recipe haciendo una llamada al back (ruta de id). Renderizar los elementos que me pide. Si yo ya tengo la info necesaria en el globalState cuando se ejecutó el getRecipes, para qué llamaría a la ruta por id que creo que trae la misma info? 

Eliminé el import Link en Home.jsx. 
Eliminé el import useEffect y useState en App.js.
Eliminé el import de axios en App.js.
Cambié el nombre App.js por App.jsx. 

App.jsx. Con el hook useLocation, implementé que el Nav no se visualice en la Landing. 
App.css. Comenté todo el css. 
Landing.jsx y Landing.module.css cambié en NavLink para que sea blanco. Ídem Card.jsx para View Details. Ídem Nav con Create Recipes. 
Agregué NavLink a Home en el Nav. 
git commit -m "Styled NavLinks in white. Added conditional render to Nav".



Cambié elementos inputs por elementos select. A futuro hacer que los option del select se rendericen con una llamada al back-end, sin hardcodearlo. 
Agregué action type FILTER_BY_DIET, la exporté al reducer. Creé el case en el reducer. 
En el reducer, modifiqué el initialState, agregando la propiedad allRecipes y modificando recies por filteredRecipes. 
En Home.jsx modifiqué recipes por allReicpes (linea 22).
La lógica no va en la action, sino en el reducer o en el componente. 
- Selene hizo un setCurrentPage(1) y un setOrden que no entendí. Reverlo en video 3. 

Modifiqué Filters.jsx para que tenga un estado local y sea un formulario controlado que hace un dispatch con toda la info junta. 
Modifiqué el Home para que en vez de renderizar state.allRecipes, renderice filteredRecipes (línea 21).
Modifiqué el Reducer para que haga la lógica de filtrar por diet y por creator. 
git commit -m "Implemented filters."

Modifiqué Nav.jsx y Filters.jsx para que mapee las opciones del select. Para eso creé un estado. El useEffect es imprescindible para no retornar una promesa. 
git commit -m "Diets options mapped in Filters". 
Próximo paso: aplicar el sort. 

Implementé el sort en Sorting.jsx copiando y adaptando Filters.jsx. Creé la action sortRecipes. 
Sorting.jsx. Agregué option none a los sorts. 
reducerIndex.js. Implementé el case SORT_RECIPES. Ahora, el Home renderiza filteredAndSortedRecipes del estado global (en vez de allRecipes). 
A futuro, tal vez es mejor que cada sort se ejecute de manera individual, ya que es raro aplicar un orden por alfabeto en simultáneo con uno por health, ya que se anulan mutuamente. 
git commit -m "Added sorting" 

Implementé SearchBar. El SearchBar es un formulario controlado. Envía una action con el submit. La action hace una llamada al back-end (ruta por name). El reducer hace que se modifique la propiedad filteredAndSortedRecipes del estado global, que es la que finalmente se termina rerenderizando. 
git commit -m "Implemented SrarchBar"  

Próximo paso: Detail, Create a recipe. 
Ver video de Selene 4. 

Componente Detail.jsx. Por ahora no funciona, no resolví bien la promesa. 

Video 4, minuto 27. Explica el formulario. 
VIdeo 5, minuto 12. Explica el Detail. 

Implementé el componente Detail. Dejé comentadas abajo en el mismo componente otras implementaciones posibles (con .then, y con redux). 
git commit -m "Implemented Detail.jsx" (a futuro ver el unmount, que no me funciona y quedó comentado).


Implementé Form.jsx excepto diets y steps que están hardcodeados. Lo implementé usando el reducer, pero también lo podría haber hecho directamente desde el componente, ya que en Form no se renderizan las recipes.  
Próximo paso: Form, actions, reducer. Y ver si me sirve cómo viene la info del back-end (arrays). 
git commit -m "Form implemented except for diets and steps (WIP)"
Los filters no están funcionando correctamente. Primero a resolver: Form.jsx, action y reducer para diets y steps. 

Home.jsx está trayendo directamente filteredAndSortedRecipes. En el reducer, el case FILTER_BY_DIET trabaja sobre la propiedad filteredRecipes del globalState. Hay que modificarlo para que se pueda ordenar aunque no estén filtrados. 
Próximo paso: arreglar o refactorizar reducer. 

back-end. recipesControllers.js. Modifiqué searchAllRecipes para desarrollar front-end sin hacer request a la api. Modificar cuando termine de desarrollar los filtros. --------->>>>> ATENCIÓN
store del Reducer. Corregí el type de EXTENSIONS por EXTENSION para poder utilizar correctamente Redux DevTools en el Browser. 
reducer. Modifiqué el global state: eliminé la propiedad filteredRecipes. Paso a usar solamente filteredAndSortedRecipes para poder hacer filter y sort en cualquier orden. Modifiqué lo necesario en el reducer.
Cambié copia por referencia a spreadoperator para no modificar el array original allRecipes (acá estaba el principal bug). 
Modifiqué la action FILTER_BY_DIET por FILTER_BY_DIET_AND_ALPHABET. 
Aparentemente los filtros funcionan bien, pero hay un problema posterior con el paginado. Además, no siempre se renderiza katogenic en el menú desplegable de Diets. 
git commit -m "Fixed Filters and redux store" 




Próximo paso: arreglar Sort. 
Eliminé la posibilidad de elegir none en Sorting para simplificar la lógica (para usar none, tendría que guardar una copia del estado antes del sort, no sé exactamente cómo hacerlo, supongo que es copiando el original allRecipes y filtrándolo con los elementos que incluya el array filteredAndSortedRecipes). 
Dividí las posibiidades de Sorting como dos actions separadas que una anula a la otra. 
Las diets las estoy trayendo desde Nav.jsx y pasando por props, pero sería mejor hacerlo con redux, y que las traiga con useSelector el componente Filters.jsx. También lo va a poder traer el componente Form. 

Agregué botón resetFilters en Filters.jsx para resetar filtros. 
git commit -m "Added resetFilters button, refactored Sorting.jsx"

Modifiqué Filters para que funcionen similar a los sorts (sin form, que dispatchen action con el handleChange). 
git commit -m "Refactored Filters.jsx"


 
Cambié la estructura: pasé SearchBar, Filters, Sorting del Nav al Home. Agregué un componente About, al que se llega con un link desde el Nav. 

Rever la lógica de Filters y Sorts para que funcionen combinados y con el Paginado. 
Cambié de NavLink a button rodeado de Link para el link a Form desde el Home. 
Filters.jsx. Reemplacé los labels for <option value="" disabled selected
git commit -m "Moved SearchBar, Filters, Sorting and Form's link from Home.jsx to Nav.jsx. Added About component"

Adaptar Sorting para que los select también tengan su título
SearchBar: reemplacé el form por un simple input con un botón. No se actualiza con el onChange para evitar tantas peticiones a la api externa. 
git commit -m "Refactored Sorting and SearchBar"
Próximo paso: Reset filters afecte también al Sorting. Funcionalidades. Esquema de Redux. 

Actions. Reordené las actions. (primero peticiones a la api externa, al final filters y sorts). Creé action getDiets. 
Reducer. Reordené el reducer de la misma forma que las actions. Creé case GET_DIETS. 
Home.jsx. Importé action getDiets. 
Dejo la action getDiets hardcodeada para no hacer peticiones a Spoonacular. 
Filters.jsx. Usé useStore para cargar diets (ya no está hardcodeado). Reemplacé el nombre filterDiet por selectedDiet. Ídem filterCreator por selectedCreator. Ídem en componente Sorting.jsx.
Form.jsx. Modifiqué la propiedad diets del initialState para que no esté hardcodeado. 
git commit -m "Implemented getDiets action. Implemented the new logic with getDiets action in Filters.jsx and in Form.jsx. Reordered actions and Reducer's cases. Renamed variables in Sorting.jsx and Filters.jsx." 

Próximo paso: steps del Form.

Back. Reordené rutas en recipesRouter.js. Reordené recipesHandlers.js. Reordené recipesControllers.js. Eliminé requires de API-KEY y { Op } sin utilizar en recipesControllers.js. Modifiqué createRecipe controller para que retorne un objeto que ya incluya las dietas, con el objetivo de mostrarlo en el form del front al hacer submit. 
Form.jsx. Cambié handleOnSubmit por handleSubmit. 
createRecipe handler. Cambié newRecipe por recipeWithDiets. La recipe se crea en el controller. EL controller retorna un objeto que no es el que se creó en la DB sino lo que quiero mostrar luego en el front al hacer submit. Ahora createRecipe action recibe del back createdRecipeRaw, que ya incluye las dietas (conclusión: antes estaba mal). 
Cambié el CREATE_RECIPE case del reducer para que actualice el global state inmediatamente con la action sin necesidad de ir al Home. 
git commit -m "Back-end: Fixed createRecipe controller to include diets in the object returned. Reordered recipesRouter.js, recipesHandlers.js and recipesControllers.js --- Front-end: modified CREATE_RECIPE case in reducer to update immediately allRecipes in the global state"
Próximo paso: ver cómo llega steps del back-end en la ruta por id y enviarlo de la misma manera desde el form en el front. 

Refactoricé createRecipe controller para simplificar la lógica. 
Spoonacular por id trae instructions que es el paso a paso (steps de analizedInstructions) convertido a string. A mí me sirve más tenerlo como array para poder mapearlo y darle estructura de elementos <p> o <li>. Esto funciona bien porque en el model de la DB estoy guardando los steps con type: DataTypes.ARRAY(DataTypes.STRING). 
Form.jsx. Agregué steps a la creación de la recipe junto con un botón que permite agregar más pasos. Con el button Add steps, se agrega un string vacío como elemento al array steps del local state. Para renderizar, se mapea el estado local dataToCreateRecipe.steps, con lo que se van a renderizar la cantidad de textarea según cuántas veces se haya hecho click en Add step. step comienza como [""], por lo tanto siempre se renderiza al menos un textarea. 
git commit -m "Added steps to Form.jsx. Local state mapped to render que quantity of texareas according to the times the button Add step was clicked".

Próximo paso: componente Detail emprolijar poniendo títulos a los que se renderiza para que se entienda. 
Luego, ver la lógicas de filtros y sorting. 

Detail.jsx. Emprolijé y reordené títulos. Agregué validaciones para todo lo que retorno, y si no llega la propiedad (si se creó la recipe, sea en la db o en Spoonacular sin algún dato) se renderiza un mensaje que indica que ese dato no fue provisto. 
Dentro del useEffect, agregué validación antes de setear el local state, por si se introduce una URL /detail/idInexistente. 
recipesHandler.js. getRecipeByIdHandler cambié 400 por 404. 
Agregué un try catch en el useEffect en Detail cuando hago la llamada al back, porque si recibo un 404 (por un id inexistente) crashea la aplicación. Agregué local state errorMessage que renderiza condicionalmente otro componente si hay error. Creé componente Error404. Agregué Go back home al componente Error404.jsx y al componente Detail.jsx (copiado del Form.jsx). 
Agregué en App.jsx que todas las rutas que no sean las anteriores dirigen a Error404. 
Modifiqué el return de Detail.jsx para que renderice normalmente el div sin el componente Error404. En caso de que se setee el estado local con error, se redirige a '/inexistentID' (con el hook useNavigate). 

git commit -m "Detail.jsx: reordered titles, added conditional renders for each property received from the back-end, added validation for inexistentsId in which case it navigates to /inexistenID. Added a local state isLoading which sets to false when the data is fetched. Added Error404.jsx component and routed it in App.jsx." 

Próximo paso: El summary que viene de la API hay que emprloijarlo. 
model Recipe.js. Cambié steps allowNull: true por false ya que en Spoonacular hay recipes sin steps. Cambié el dataTypes de steps a type: DataTypes.ARRAY(DataTypes.TEXT) porque hay steps de más de 255 caracteres. 
En Detail.jsx agregué validación steps[0] !== '' porque desde el Form siempre envío al menos un elemento porque así inicio su estado local. 
git commit -m "Detail.jsx: improved summary render. Improved steps validation. Recipe.js model: updated steps Datatypes and allowNull."  


Copié el isLoading del Detail al Home y adapté el useEffect para que contenga un async await, para que se ejecuten las actions antes de ejecutar setIsLoading(false). Creé una nueva api_key, guardada en .env para cuando tengo code 402. 
git commit -m ".env: Added an alternative API_KEY. Home.jsx: added a loader".


Dejé más legibles los archivos que permiten siwtchear entre recibir data de Spoonacular y hardcodearla. Ubiqué la guía de estos tres archivos al principio de este archivo txt. 
Filters.jsx. Agregué la option 'all' al creator que la había borrado por error. 
git commit -m "Improved comments to explain how to switch between fetching data from Spoonacular and hardcoding it in files recipesControllers.js, apiRecipesHelpers.js, actionsIndex.js. Added 'all' option to creator filter in Filters.jsx." 


Card.jsx. Detail.jsx. Reemplacé name, image y diets por los que tenía en Detail.jsx. Agregué healthscore para chequear si funciona bien el sort. Reemplacé NavLink por Link dentro de un botón. 
reducerIndex.js. Arreglé el case SORT_RECIPES_BY_HEALTHSCORE que ordenaba al revés de como esperaba. 
git commit -m "Reordered elements in Card.jsx. Fixed case sort_recipe_by_health in reducer.js to sort properly"

Modifiqué case SORT_RECIPES_BY_ALPHABET para que ordene siendo case insensitive. 
git commit -m "Fixed case sorte_recipe_alphabet in reducer.js". 
A futuro ver en el ordenamiento por healthscore que ordena por la api o por client por separado (pero también puede ser por cómo queda seteado el filter creator).

Próximo paso: Searchbar lograr que al no encontrar el name, retorne algo. Para eso, probar agregar try catch en action getRecipesByName. Lograr que se puedan volver a ver las demás recetas (eliminando este filtro searchBar). Mejor, trycatch en el dispatch desde SearchBar. 

SearchBar. Copié el Reset de Filters.jsx. 
actionsIndex.js: agregué un trycatch en actionsIndex.js a getRecipesByName para que si no encuentra la receta responda con un alert. Lo quiero hacer con try catch en SearchBar para renderizar condicionalmente un mensaje que diga "No recipes found", pero no me funciona. 
git commit -m "Handled errors in getRecipesByName action when no recipes are found un the searchbar. Copied the reset from Filters.jsx to SearchBar.jsx. 

Próximo paso:
- Descubrir por qué no puedo hacer try catch en SearchBar.jsx
- Añadir validaciones al Form.jsx. 

Eliminar App.css, reportWebVitals.js, setupTests.js, App.test.js. A futuro borrar index.css. 
Reorganicé carpetas de componentes. 
- Views: Landing, Home, Detail. Form. 
Reemplacé en index.js ReadDOM.render por createRoot. 
Landing.jsx. Reemplacé NavLink por Link dentro de button. 
Nav.jsx. Reemplacé NavLink por Link. 
Filters.jsx. Agregué key al map. 
Eliminté selected (en selected disabled) de Filters.jsx y Sorting.jsx porque no produce efecto y genera un warning en consola. 
Agregué un css básico al Nav. 
Reemplacé el nombre del componente Cards por CardsContainer. 
Eliminé Link de CardsContainer.jsx. 
Agregué un css básico a CardsContainer. 
Agregué varios punto y coma al reducer. 

Apunte: CardsContainer (en mi caso Home que le pasa por props a CardsContainer) hace useSelector y no le interesa cómo redux trae la info, Redux y React funcionan por separado. A su vez, redux hace una llamada al back y tampoco le interesa cómo el server trae la info. 

git commit -m "Added basic css, fixed minor issues in multiple files"

Próximo paso: ver última lecture de Jorge Vega y seguir anotando pasos. 

Apunte. 
Redux no puede tener incertidumbre. Para operaciones asíncronas que devuelvan promesas, el store requiere de compose. En las actions, las actions creators con operaciones asíncronas no puede retornar una action, sino que retornan una nueva función que es async, que toma como argumento dispatch y retorna el dispatch de la action. 
Puedo probar la action con jsonplaceholder. 
En el reducer no se modifica el estado, sino que se pisa, siempre se retorna un nuevo global state. 
El useSelector es como un watcher. Cuando el global state cambia, lo que guardo con el useSelector se actualiza y se rerenderiza el componente. Home hace el dispatch cuando se monta, CardsContainer hace el useSelector. 

---- Filtros ----
Para hacer filtros en el back (por ejemplo filtrar recetas por creador), se crea un nuevo endpoint que luego es llamado en el front con una action de redux. 
Para hacer filtros en el front, se hace en el reducer. De la info general del estado global, un case filtra esa info y se guarda en una segunda propiedad del estado global sin pisar la propiedad desde donde se sacó la info general. 

---- Flujo de redux con operaciones async: ----
El componente Home se monta, se ejecuta useEffect, dentro del useEffect se ejecuta dispatch con action creator como argumento. La action creator ejecutada retorna una función async. La función async es tomada por thunkMiddleware. Thunkmiddleware ejecuta la función async, hace dispatch de la action final. Esta action final va al reducer. El reducer evalúa la aaction type, entra en un case, retorna un nuevo estado global que pisa al anterior

Array de dependencias: variables que, en caso de que esa variable se modifique, se ejecuta nuevamente el useEffect. Si no se pone el array de dependencias, se puede loopear el useEffect. Las variables que use dentro del useEffect, ponerlas dentro del array de dependencias. 

En las actions async, reemplacé recipesRaw por apiData y recipesClean por allRecipes. 
Pasé las actions types a un archivo separado. 
Cambié el nombre de la action getRecipes por getAllRecipes. 
Form. Uní label, br, input, br en div. 
Form. Cambié el nombre de dataToCreateRecipe y setdataToCreateRecipe por form y setForm. 
Form. Cambié <input></input> por <input />
Form. Agregar validaciones. 

git commit -m "Implemented validations to Form.jsx. Fixed minor issues in multiple files"







////////////////////
Resumen de pasos aplicación React Redux:
1. Configuración: CRA, npm i, borrar lo innecesario. Probar renderizar un <div> en App. 
2. Rutas. BrowserRouter en index.js y App.jsx. views. Landing, Home, Detail, Form. 
3. NavBar. Link. para desarrollar: todas las views. 
 components. 
4. CardsContainer. Mapear array (de recipes, videogames, pokemons, countries, etc). Renderizar una Card por cada objeto mapeado pasándole por props las propiedades del objeto que se quieran renderizar. Antes de usar Redux, probarlo con un array de objetos inventado (copiarlo de api externa o de Postman). 
5. Card. Renderizar props recibidas. link a Detail. 
6. css básico. margin, border, display, flex-direction, flex-wrap. En Nav, CardsContainer, Card. 
7. redux store. store (copiar configuración básica), reducer, actions, actions-types. En index.js, Envolver BrowserRouter (o App si no hay BrowserRouter) dentro de Provider pasándole el store. Chequear que haya global state en redux devtools (browser). Probar agregar el array de objetos hardcodeado al globalState y traerlo con useSelector desde CardsContainer para mapearlo. 
8. actions y reducer. request al server. En componente, useSelector y useDispatch. 
9. Form. initialState, useState. form, label, input, button. value controlado por el localState. Chequear con Components en el browser. handleChange modifica el localState. handleSubmit hace dispatch. Validaciones. 

////////////////////
