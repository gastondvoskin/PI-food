Para comenzar a trabajar: npm start en api

Inicio: 13 de abril. 
PI descargado. Dejo una copia del BLANK en z. PI-Food-BLANK.
Repositorio git inicializado y sincronizado con gitHub. 
Archivo .env creado (falta el puerto).
DB food creada. 

Dudas:
- Por ahora los endpoints me muestran un 401, es porque para hacer requests tengo que hacerlo con la apikey creada? 
- Cuántas requests diarias puedo hacer? Me conviene guardar todo en mi DB hasta que termine el desarrollo? 
- index de routes. // Configurar los routers // Ejemplo: router.use('/auth', authRouter); // ??
- Cómo hago para ver TODOS los resultados al hacer el llamado a la API? No sé ni siquiera cuántos recipes hay. 
- Cómo manejo las diets que están en propiedades vs las que están en la propiedad Diets? Se duplican, es necesario usar las propiedades sueltas además de las de la propiedaD Diets? Por qué no incluir diaryFree dentro de las propiedades que van por separado igual que vegetarian, vegan y flutenFree? 
- Cómo se están relacionando los modelos?

- React. npm start: creo que servía para crear y actualizar el bundle. Confirmar. 
- React-router-dom está en versión 5, en vez de 6.3.0. Debería actualizarla? 
- El archivo App.jsx tendría que tener extensión .jsx? Es necesario importar React en ese archivo? 



DB: relación many-to-many entre modelos Recipe y Diets. Comentados porque todavía no creé los modelos. 
DB: crear dos modelos -> recetas y dietas. 
npm i dentro de api
npm start. Levanta bien el server (dice Listening on port 3001 y Connected to DB). 
model Recipe: bien conectado con DB. Si le agrego atributos, se actualiza correctamente. 

Consignas: 
API: https://spoonacular.com/food-api
enpoints permitidos: 
https://api.spoonacular.com/recipes/complexSearch
https://api.spoonacular.com/recipes/complexSearch&addRecipeInformation=true
tipos de dieta: propiedades vegetarian, vegan, glutenFree, las incluidas en propiedad diets. 
https://api.spoonacular.com/recipes/{id}/information

Buscar recetas.
Visualizar la información de las recetas.
Filtrarlas.
Ordenarlas.
Crear nuevas recetas.
Filtrado y ordenamiento: no se pueden usar endpoints de api externa. 

commit added model Recipe
cambié Diets por Diet en archivo db.js

Creé la primera ruta. GET | /recipes/:idRecipe todavía sin implementar.
Probé la ruta en Postman y funciona. 
Por ahora, no modularizar. 
Siguiente paso: implementar esta ruta para ver si funcionan las requests a la api externa y si puedo combinarlo con la db. 
Instalé axios dentro de api. 
Cambié api_key como estaba en la consinga por apiKey, que es lo que indica la documentación de la API externa. 
La request a la API externa funciona correctamente. Guardé la response en archivo resExamp.json por si me quedo sin requests por día. 
En modelo Recipe, cambié el atributo healthScore por healthscore (minúscula).
Creé un primer registro en la tabla Recipes mediante sql shell. El código para hacerlo está en el archivo index de routes. Seteé force en true en archivo index general. 
Terminé la implementación de la primera ruta. Para no hacer requests por error a la API externa, dejé comentado el else de la primera ruta. 
Siguiente paso: seguir trabajando en archivo index de routes. Pasar a la segunda ruta. A futuro, modularizar. 

Creé la segunda ruta. '/recipes' con query name . Interpreté que es de esta manera aunque la consigna ubica el ? después del name en vez de ubicarlo antes. 
Implementé guardar las recetas que coinciden con el name del query provenientes de la DB. 
Siguiente paso: guardar las provenientes de la API externa. 
Guardé la response de la API externa al request general de recipes en mi archivo resExample.json. 
Implementé el llamado a la API externa. 
Agregué esta request a Postman. 
Implementé la segunda ruta '/recipes' con query name . No sé si busca otros nombres de la API externa porque todavía no sé cómo ver todos los recipes (tal vez debería buscar alguno por id para luego chequear si viene también buscando por su name). 
A futuro implementar que busque con mayúsculas o minúsculas y que la búsqueda no requiera ser exacta. 

Siguiente paso: tercera ruta. 
Armé la request en Postman. 
Desestructuré los datos que llegan por body en la ruta. 
Con el método create del modelo, creé una recipe en la ruta. Para verla en la DB, recordar apretar enter hasta que aparezca el registro. 
Para ver DB en psql, al ser varios registros, recordar \x para ver con claridad. 
En la función que crea el modelo (archivo Recipe.js), agregué el atributo diets. 
A futuro rever diets en Recipe.js, en ruta GET /recipes , en ruta POST /recipes y en Postman. 

Creé la ruta 4. GET /diets . Tomé la petición de la ruta 2, a futuro modularizar esta función. 
Inicialicé allDiets con tres propiedades (está hardcodeado o está ok). Las demás propiedades las tomé haciendo dos bucles: el primer recorre todas las apiRecipes, el segundo recorre dentro de cada apiRecipe su propiedad diets. Cada diet que no esté incluida en el arreglo allDiets se pushea a este arreglo. 
Siguiente paso: agregar los elementos del arreglo allDiets a la DB para que ya queden guardados ahí. 
Agregué el modelo Diet al archivo index.js de rutas. A futuro, modularizar. 
Quité el atributo created de la función que crea el modelo Diet (archivo Diet.js). 
Con un bucle forEach, agregué cada elemento del arreglo allDiets a la DB. 
El arreglo allDiets tiene un elemento glutenFree y un elemento gluten Free. Rever a futuro si está ok. 
A futuro, hacer que la petición a la API externa traiga todos los recipes, no solamente 10 (es la misma función que voy a necesitar para la ruta 2). 
Siguiente paso back-end: relacionar modelos (hasta ahora tengo la relación many-to-many, pero estoy tratando a las tablas como entidades totalmente separadas).
Paso futuro para el back-end: modularizar. 
git commit -m "added route get /diets"



FRONT-end
npm start: para compilar. 
Siguiente paso: comenzar front-end. 
Para el front-end, no enfocarme en los estilos. Ir a lo funcional. 
npm i en client.
Instalé la extensión Live Server en VSC. Abrí el HTML con Live Server. 
Dejé como estaban web vitals del package json y el archivo reportWebVitals.js contenido en src. Por las dudas de que los necesito a futuro.  
Probé agregar un div al html y se actualiza correctamente con el Live Server. 
npm run build lo voy a usar recién para el deployment. 
Cambié el title del html a PI-Food. 
Probé agregar un div desde el componente App y funciona correctamente. 
Cambié el background-color del body (archivo index.css) a black y el color a white.

FLUJO: 
html -> index.js -> App.js -> Landing.jsx -> 
-> Home.jsx -> SearchBar.jsx
        -> Cards.jsx -> Detail.jsx
        -> Filters.jsx
        -> Sorting.jsx 
        -> Pagination
                                    
                        

Actualicé las versiones en package.json de: React, React-dom, React-router-dom, React-redux, React-scripts. Volví a hacer npm i. 
Siguiente paso: hacer el ruteo desde el archivo index.js 
Archivo index.js . Reemplacé el código de ReactDom.render(...) por otro, dejando el que estaba como comentado. 
archivo index.js. Envolví al componente App en el BrowserRouter (y lo importé). A futuro, envolver con Provider store (para conectar con redux). 
Archivo App.js. Hice los imports de React, Routes y Route. Reescribí el componente App, cambiándolo a función flecha y agregándole rutas. 
Creé la carpeta components dentro de src. Dentro de components, creé la carpeta Landing, y dentro de ella Landing.jsx y Landing.module.css. Exporté el componente Landing, lo importé en App.js y creé la ruta correspondiente. 

Siguiente paso: implementar Landing.jsx 
Creé carpeta assets dentro de src. Ahí van las imágenes. 
Landing. Importé React. Agregué un breve texto. Importé styles y agregué una imagen al archivo landing.module.css. Cambié la imagen directamente al Landing.jsx para controlar su opacity desde el module.css. 
A futuro, acomodar los estilos. 
Agregué botón para ingresar a la Home desde la Landing. 
Agregué archivo Home, todavía sin implementar. 
Agregué ruta a Home desde App.js. 
Hasta ahora se puede hacer npm start, entrar a localgost:3000/landing, y desde allí apretar el botón que redirige a /home y carga correctamente. 
git commit -m "implemented Landing and added Home"

Siguiente paso: Crear componentes que se renderizan en Home.jsx. Basarme en Landing y en proyectos anteriores como Rick, reactdesdecero y CP. 
Creé los archivos de lso componentes que se renderizan en Home. Son los siguientes: SearchBar, Cards, Filters, Sorting, Pagination. 
Creé un componente estándar en cada componente que se renderiza en Home, lo exporté, lo importé y rendericé en Home.jsx. 

Siguiente paso: crear componente Detail y renderizarlo en Cards.jsx . Lo correspondiente para Form. 